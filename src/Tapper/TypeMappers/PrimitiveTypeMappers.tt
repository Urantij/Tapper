<#@ template language="C#" linePragmas="false" debug="false" hostspecific="false"#>
<#@ assembly name="System.Core" #>
<#@ import namespace="System" #>
<#@ import namespace="System.Linq" #>
<#@ import namespace="System.Text" #>
<#@ import namespace="System.Collections.Generic" #>
<#@ output extension=".cs" #>
<#
    Dictionary<Type, string> primitiveTypeMap = new()
    {
        { typeof(bool), "boolean" },
        { typeof(byte), "number" },
        { typeof(sbyte), "number" },
        { typeof(decimal), "number" },
        { typeof(double), "number" },
        { typeof(float), "number" },
        { typeof(int), "number" },
        { typeof(uint), "number" },
        { typeof(long), "number" },
        { typeof(ulong), "number" },
        { typeof(short), "number" },
        { typeof(ushort), "number" },
        { typeof(object), "any" },
        { typeof(string), "string" },
        { typeof(Uri), "string" },
        { typeof(Guid), "string" },
    };
#>
// <auto-generated>
// THIS (.cs) FILE IS GENERATED BY Tapper
// </auto-generated>
#nullable enable
using System;
using Microsoft.CodeAnalysis;

namespace Tapper.TypeMappers;

public class CharTypeMapper : ITypeMapper
{
    public ITypeSymbol Assign { get; }

    public CharTypeMapper(Compilation compilation)
    {
        Assign = compilation.GetTypeByMetadataName("System.Char")!;
    }

    public string MapTo(ITypeSymbol typeSymbol, ITranspilationOptions options)
    {
        if (SymbolEqualityComparer.Default.Equals(typeSymbol, Assign))
        {
            if (options.SerializerOption is SerializerOption.MessagePack)
            {
                return "number";
            }
            else
            {
                return "string";
            }
        }

        throw new InvalidOperationException($"CharTypeMapper is not support {typeSymbol.ToDisplayString()}.");
    }
}

<# foreach(var type in primitiveTypeMap){ #>
public class <#= type.Key.Name #>TypeMapper : ITypeMapper
{
    public ITypeSymbol Assign { get; }

    public <#= type.Key.Name #>TypeMapper(Compilation compilation)
    {
        Assign = compilation.GetTypeByMetadataName("<#= type.Key.FullName #>")!;
    }

    public string MapTo(ITypeSymbol typeSymbol, ITranspilationOptions options)
    {
        if (SymbolEqualityComparer.Default.Equals(typeSymbol, Assign))
        {
            return "<#= type.Value #>";
        }

        throw new InvalidOperationException($"<#= type.Key.Name #>TypeMapper is not support {typeSymbol.ToDisplayString()}.");
    }
}

<# } #>

public static class PrimitiveTypeMappers
{
    public static ITypeMapper[] Create(Compilation compilation)
    {
        var mappers = new ITypeMapper[<#= primitiveTypeMap.Count + 1 #>];

<# foreach(var (it, index) in primitiveTypeMap.Select((x, index) => (x, index))){ #>
        mappers[<#= index #>] = new <#= it.Key.Name #>TypeMapper(compilation);
<# } #>
        mappers[<#= primitiveTypeMap.Count #>] = new CharTypeMapper(compilation);

        return mappers;
    }
}
